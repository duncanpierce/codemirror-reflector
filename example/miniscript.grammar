// https://lezer.codemirror.net/docs/guide/

// Import props needed to define scopes, definitions and uses
@external prop scope from "../src/scope"
@external prop definition from "../src/definition"
@external prop use from "../src/use"

// Mark each node which defines a new scope - FunctionDeclaration has FunctionDefinition outside the new scope and its parameters inside
@top Program[scope] { declaration* }
FunctionScope[scope] { FormalParameters Block }
Block[scope] { OpenBrace Statement* CloseBrace }

// Mark each definition of a function or variable
GlobalVariableDefinition[definition="wholeScope"] { identifier }
FunctionDefinition[definition="wholeScope"] { identifier }
ParameterDefinition[definition="wholeScope"] { identifier }
LocalVariableDefinition[definition="redefines,overridePrevious"] { identifier }

// Mark each use of a function or variable
VariableUse[use] { identifier }
FunctionUse[use] { identifier }

// End of extra things for Reflector - everything below is ordinary grammar

@skip { space | Comment }

@tokens {
    space { $[ \t\n\r]+ }
    Comment { "#" ![\n]* }
    identifier { $[a-zA-Z] $[a-zA-Z0-9]* }
    Number { $[0-9]+ }
    String { '"' ![\n"] '"' }
}

@precedence {
    neg @left,
    mul @left,
    add @left,
    cmp @left
}

list<k> { "(" (k ("," k)*)? ")" }
Function { @specialize<identifier,"func"> }
Var { @specialize<identifier,"var"> }
Return { @specialize<identifier,"return"> }

declaration {
    FunctionDeclaration |
    GlobalVariableDeclaration
}

FormalParameters { list<ParameterDefinition> }
ActualParameters { list<Expression> }
ReturnStatement { Return Expression }
Assignment { VariableUse "=" Expression }
LocalVariableDeclaration { Var LocalVariableDefinition }
FunctionDeclaration { Function FunctionDefinition FunctionScope }
GlobalVariableDeclaration { Var GlobalVariableDefinition ";" }
Statement { (LocalVariableDeclaration | Assignment | FunctionCall | ReturnStatement) ";" }

OpenBrace[closedBy=CloseBrace] { "{" }
CloseBrace[openedBy=OpenBrace] { "}" }
OpenParen[closedBy=CloseParen] { "(" }
CloseParen[openedBy=OpenParen] { ")" }

Expression {
    Number |
    String |
    VariableUse |
    Unary |
    Binary |
    SubExpression |
    FunctionCall
}

Unary {
    !neg "-" Expression
}

Binary {
    Expression !mul "*" Expression |
    Expression !mul "/" Expression |
    Expression !add "+" Expression |
    Expression !add "-" Expression | 
    Expression !cmp ("<" | ">" | "=" | "<>" | "<=" | ">=") Expression
}

SubExpression { OpenParen Expression CloseParen }

FunctionCall { FunctionUse ActualParameters }
